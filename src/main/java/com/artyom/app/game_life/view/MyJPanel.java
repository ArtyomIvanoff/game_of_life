/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.artyom.app.game_life.view;

import com.artyom.app.game_life.cells.CellSet;
import com.artyom.app.game_life.cells.CellSetFactory;
import com.artyom.app.game_life.cells.PairIndices;
import com.artyom.app.game_life.controller.CellController;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.geom.Rectangle2D;
import javax.swing.Timer;

/**
 *
 * @author 122
 */
public class MyJPanel extends javax.swing.JPanel implements ActionListener {

    public final int WIDTH_PANEL = 400;
    public final int HEIGHT_PANEL = 400;
    private int rows;
    private int columns;

    private CellSetFactory cellSetFactory;
    private CellSet cellSet;
    private CellController cellController;

    public CellController getCellController() {
        return cellController;
    }

    public void setCellController(CellController cellController) {
        this.cellController = cellController;
    }
    // the size of cell's side in pixels
    private int sizeCell = 8;
    // to decrease the computations of positions of cells on the panel
    private int[] scales;
    private Timer timer;
    private int fps = 10;
    private int num_alived = 0;
    private int percent_alived = 25;
    private CellSet.Mode cellSet_mode = CellSet.Mode.INVERT_CELL;
    private boolean isPaused = true;
    private Color cellColor = Color.RED;

    public CellSetFactory getCellSetFactory() {
        return cellSetFactory;
    }

    public void setCellSetFactory(CellSetFactory cellSetFactory) {
        this.cellSetFactory = cellSetFactory;
    }

    public CellSet getCellSet() {
        return cellSet;
    }

    public void setCellSet(CellSet cellSet) {
        this.cellSet = cellSet;
    }

    public int getNum_alived() {
        return num_alived;
    }

    public int getSizeCell() {
        return sizeCell;
    }

    public void setSizeCell(int size) {
        this.sizeCell = size;
    }

    public int getFps() {
        return fps;
    }

    public void setFps(int fps) {
        this.fps = fps;
    }

    public CellSet.Mode getCellSet_mode() {
        return cellSet_mode;
    }

    public void setCellSet_mode(CellSet.Mode cellSet_mode) {
        this.cellSet_mode = cellSet_mode;
    }

    public boolean isPaused() {
        return isPaused;
    }

    public void setPause(boolean isPaused) {
        this.isPaused = isPaused;
    }

    /**
     * Creates new form MyJPanel
     */
    public MyJPanel() {
        initComponents();

        configureCellSet();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setPreferredSize(new java.awt.Dimension(400, 400));
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                formMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );

        getAccessibleContext().setAccessibleName("workPanel");
        getAccessibleContext().setAccessibleParent(this);
    }// </editor-fold>//GEN-END:initComponents

    private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked
        // TODO add your handling code here:
        int row = evt.getY() / sizeCell;
        int column = evt.getX() / sizeCell;

        switch (cellSet_mode) {
            case ADD_GLIDER:
                cellSet.addGlider(row, column);
                break;
            case INVERT_CELL:
                cellSet.invertCellState(row, column);
                break;
            default:
        }

        // update cellSet for the cell controller
        cellController.setCellSet(cellSet);
    }//GEN-LAST:event_formMouseClicked


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    final void configureCellSet() {
        rows = HEIGHT_PANEL / sizeCell;
        columns = WIDTH_PANEL / sizeCell;

        // assume that the number of rows equals to columns' one
        scales = new int[rows];
        for (int i = 0; i < rows; i++) {
            scales[i] = i * sizeCell;
        }

        cellSetFactory = new CellSetFactory(rows, columns);

        cellSet = cellSetFactory.newInstance(percent_alived);

        //cellSet = cellSetFactory.newGlider(10, 10);
        cellController = new CellController(cellSet);

        // make animation 
        timer = new Timer(1000 / fps, this);
        timer.start();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g); //To change body of generated methods, choose Tools | Templates.
        Graphics2D g2 = (Graphics2D) g;
        g2.setBackground(Color.white);

        num_alived = 0;
        g2.setColor(cellColor);
        boolean[][] cells = cellSet.getCells();
        for (int i = 0; i < cells.length; i++) {
            for (int j = 0; j < cells[i].length; j++) {
                // x coordinate is column, y coordinate is row
                if (cells[i][j]) { // true means alived cell
                    g2.fillRect(scales[j], scales[i], sizeCell, sizeCell);
                    num_alived++;
                }
            }
        }
        
        // compute next generation of the cells
        if (!isPaused) {
            cellSet = cellController.getNextGeneration();
        }
    }

    /*
     Make animation
     */
    @Override
    public void actionPerformed(ActionEvent e) {
        // update the cell set according to the timer (every 1000/fps ms)
        repaint();
    }
}
